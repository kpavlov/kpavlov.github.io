<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on The Culture of Code</title>
    <link>https://konstantinpavlov.net/tags/performance/</link>
    <description>Recent content in Performance on The Culture of Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Mar 2014 12:30:28 +0200</lastBuildDate>
    
	<atom:link href="https://konstantinpavlov.net/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Video: Scalable Memory Allocation using jemalloc Tech Talk (1/11/2011)</title>
      <link>https://konstantinpavlov.net/blog/2014/03/01/video-scalable-memory-allocation-using-jemalloc-tech-talk-1/11/2011/</link>
      <pubDate>Sat, 01 Mar 2014 12:30:28 +0200</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2014/03/01/video-scalable-memory-allocation-using-jemalloc-tech-talk-1/11/2011/</guid>
      <description>Video: Scalable Memory Allocation using jemalloc - Tech Talk (1/11/2011)
jemalloc project: https://github.com/jemalloc/jemalloc</description>
    </item>
    
    <item>
      <title>Chronicle</title>
      <link>https://konstantinpavlov.net/blog/2014/02/19/chronicle/</link>
      <pubDate>Wed, 19 Feb 2014 12:30:42 +0200</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2014/02/19/chronicle/</guid>
      <description>Chronicle by Peter Lawrey:
 This library is an ultra low latency, high throughput, persisted, messaging and event driven in memory database. The typical latency is as low as 80 nano-seconds and supports throughput of 5-20 million messages/record updates per second.
This library also supports distributed, durable, observable collections (Map, List, Set) The performance depends on the data structures used, but simple data structures can achieve throughput of 5 million elements or key/value pairs in batches (eg addAll or putAll) and 500K elements or key/values per second when added/updated/removed individually.</description>
    </item>
    
    <item>
      <title>JVM Profiling Mode</title>
      <link>https://konstantinpavlov.net/blog/2014/01/18/jvm-profiling-mode/</link>
      <pubDate>Sat, 18 Jan 2014 12:33:12 +0300</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2014/01/18/jvm-profiling-mode/</guid>
      <description>There is no sense to run profiler in instrumentation mode on a high load.
Instead of using instrumentation you should use sampling mode.
This article describes the difference between instrumentation and sampling modes. JVisualVM is a good free tool for this task.</description>
    </item>
    
  </channel>
</rss>