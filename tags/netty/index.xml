<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Netty on The Culture of Code</title>
    <link>https://konstantinpavlov.net/tags/netty/index.xml</link>
    <description>Recent content in Netty on The Culture of Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://konstantinpavlov.net/tags/netty/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing Automatic Reconnection for Netty Client</title>
      <link>https://konstantinpavlov.net/blog/2015/07/08/implementing-automatic-reconnection-for-netty-client/</link>
      <pubDate>Wed, 08 Jul 2015 07:48:05 +0000</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2015/07/08/implementing-automatic-reconnection-for-netty-client/</guid>
      <description>&lt;p&gt;One of the first requirement of &lt;a href=&#34;https://github.com/kpavlov/jreactive-8583&#34; target=&#34;_blank&#34;&gt;Netty ISO8588 client connector&lt;/a&gt; was the support for automatic reconnect.&lt;/p&gt;

&lt;p&gt;One of the first receipts I came across was &lt;a href=&#34;http://tterm.blogspot.com/2014/03/netty-tcp-client-with-reconnect-handling.html&#34; target=&#34;_blank&#34;&gt;Thomas Termin&amp;rsquo;s one&lt;/a&gt;. He suggests adding a ChannelHandler which will schedule the calling of client&amp;rsquo;s &lt;code&gt;connect()&lt;/code&gt; method once a Channel becomes inactive. Plus adding ChannelFutureListener which will re-create a bootstrap and re-connect if initial connection was failed.&lt;/p&gt;

&lt;p&gt;Although this is a working solution, I had a feeling that something is not optimal. Namely, the new Bootstrap is being created on every connection attempt.&lt;/p&gt;

&lt;p&gt;So, I created a FutureListener which should be registered once a Channel is closed.&lt;/p&gt;

&lt;p&gt;Here is the &lt;a href=&#34;https://github.com/kpavlov/jreactive-8583/blob/master/src/main/java/org/jreactive/iso8583/netty/pipeline/ReconnectOnCloseListener.java&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;ReconnectOnCloseListener&lt;/code&gt;&lt;/a&gt; code:&lt;/p&gt;

&lt;p&gt;```java ReconnectOnCloseListener.java
    public class ReconnectOnCloseListener implements ChannelFutureListener {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private final Logger logger = getLogger(ReconnectOnCloseListener.class);

    private final Iso8583Client client;
    private final int reconnectInterval;
    private final AtomicBoolean disconnectRequested = new AtomicBoolean(false);
    private final ScheduledExecutorService executorService;

    public ReconnectOnCloseListener(Iso8583Client client, int reconnectInterval, ScheduledExecutorService executorService) {
        this.client = client;
        this.reconnectInterval = reconnectInterval;
        this.executorService = executorService;
    }

    public void requestReconnect() {
        disconnectRequested.set(false);
    }

    public void requestDisconnect() {
        disconnectRequested.set(true);
    }

    @Override
    public void operationComplete(ChannelFuture future) throws Exception {
        final Channel channel = future.channel();
        logger.debug(&amp;quot;Client connection was closed to {}&amp;quot;, channel.remoteAddress());
        channel.disconnect();
        scheduleReconnect();
    }

    public void scheduleReconnect() {
        if (!disconnectRequested.get()) {
            logger.trace(&amp;quot;Failed to connect. Will try again in {} millis&amp;quot;, reconnectInterval);
            executorService.schedule(
                    client::connectAsync,
                    reconnectInterval, TimeUnit.MILLISECONDS);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
To establish the connection I use the following [code][Iso8583Client]:

```java
    reconnectOnCloseListener.requestReconnect();
    final ChannelFuture connectFuture = bootstrap.connect();
    connectFuture.addListener(connFuture -&amp;gt; {
        if (!connectFuture.isSuccess()) {
            reconnectOnCloseListener.scheduleReconnect();
            return;
        }
        Channel channel = connectFuture.channel();
        logger.info(&amp;quot;Client is connected to {}&amp;quot;, channel.remoteAddress());
        setChannel(channel);
        channel.closeFuture().addListener(reconnectOnCloseListener);
    });
    connectFuture.sync();// if you need to connect synchronously
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you want to disconnect, you&amp;rsquo;ll need to disable automatic reconnection first:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    reconnectOnCloseListener.requestDisconnect();
    channel.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution works fine so far (&lt;a href=&#34;https://github.com/kpavlov/jreactive-8583/blob/master/src/test/java/org/jreactive/iso8583/example/ClientReconnectIT.java&#34; target=&#34;_blank&#34;&gt;integration test&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Another option is to add a ChannelOutboundHandler which will handle disconnects.&lt;/p&gt;

&lt;h3 id=&#34;links&#34;&gt;Links&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Sources: &lt;a href=&#34;https://github.com/kpavlov/jreactive-8583/blob/master/src/main/java/org/jreactive/iso8583/netty/pipeline/ReconnectOnCloseListener.java&#34; target=&#34;_blank&#34;&gt;ReconnectListener&lt;/a&gt;, &lt;a href=&#34;https://github.com/kpavlov/jreactive-8583/blob/master/src/main/java/org/jreactive/iso8583/client/Iso8583Client.java#L67&#34; target=&#34;_blank&#34;&gt;Client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StackOverflow: &lt;a href=&#34;http://stackoverflow.com/a/20881135/3315474&#34; target=&#34;_blank&#34;&gt;answer one&lt;/a&gt;, &lt;a href=&#34;http://stackoverflow.com/a/9351628/3315474&#34; target=&#34;_blank&#34;&gt;answer two&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Netty: How to Initiate SSL Handshake From Client</title>
      <link>https://konstantinpavlov.net/blog/2013/04/23/netty-how-to-initiate-ssl-handshake-from-client/</link>
      <pubDate>Tue, 23 Apr 2013 12:55:57 +0000</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2013/04/23/netty-how-to-initiate-ssl-handshake-from-client/</guid>
      <description>&lt;p&gt;I have had spent some time recently making netty 3.6 sending some message when connection has been established.&lt;/p&gt;

&lt;p&gt;What documentation suggests to do is to extend &lt;code&gt;SimpleChannelUpstreamHandler&lt;/code&gt; and override method &lt;code&gt;channelConnected(...)&lt;/code&gt;.
It works fine unless &lt;code&gt;SslHandler&lt;/code&gt; is used in the pipeline.
If handler is present, &lt;code&gt;channelConnected()&lt;/code&gt; was never called on my handler.

The problem was caused by client, which did not initialized SSL handshake on connection.
Until handshake completed, no other &lt;code&gt;ChannelHandlers&lt;/code&gt; are notified.
Hopefully, there is a convenient way to initiate handshake on the client. Netty documentation states:&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;handshake&#34;&gt;Handshake&lt;/h2&gt;

&lt;p&gt;If &lt;code&gt;isIssueHandshake()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (default) you will need to take care of
calling &lt;code&gt;handshake()&lt;/code&gt; by your own. In most situations were &lt;code&gt;SslHandler&lt;/code&gt; is
used in &amp;lsquo;client mode&amp;rsquo; you want to issue a handshake once the
connection was established. if &lt;code&gt;setIssueHandshake(boolean)&lt;/code&gt; is set to
&lt;code&gt;true&lt;/code&gt; you don&amp;rsquo;t need to worry about this as the SslHandler will take
care of it.
&lt;a href=&#34;http://netty.io/3.6/api/org/jboss/netty/handler/ssl/SslHandler.html&#34; target=&#34;_blank&#34;&gt;http://netty.io/3.6/api/org/jboss/netty/handler/ssl/SslHandler.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, you should set &lt;code&gt;isIssueHandshake&lt;/code&gt; on &lt;code&gt;SslHandler&lt;/code&gt; before establishing the connection:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SslHandler sslHandler = new SslHandler(engine);
setIssueHandshake(true);
pipeline.addLast(&amp;quot;ssl&amp;quot;, sslHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, server got hadshaked and &lt;code&gt;SslHandler&lt;/code&gt; fired connected &lt;code&gt;ChannelStateEvent&lt;/code&gt; to other &lt;code&gt;UpstreamHandlers&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>