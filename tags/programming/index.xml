<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on The Culture of Code</title>
    <link>https://konstantinpavlov.net/tags/programming/index.xml</link>
    <description>Recent content in Programming on The Culture of Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://konstantinpavlov.net/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>UI-First Development</title>
      <link>https://konstantinpavlov.net/blog/2017/03/07/ui-first-development/</link>
      <pubDate>Tue, 07 Mar 2017 08:48:34 +0000</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2017/03/07/ui-first-development/</guid>
      <description>

&lt;p&gt;One of the callenge for start-up or any new project is to reduce amount of work yet to deliver full-featured product.
Agile methodologies address this challenge on project management level.
Let&amp;rsquo;s discuss one more approach to address it on architecture level: &lt;strong&gt;&lt;em&gt;UI-first development.&lt;/em&gt;&lt;/strong&gt;
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;Delivering prototype to the client early is often very important to project success.
Client may have only general idea of a product he wants, and prototyping may save a lot of time
and efforts of the team by reducing amount of unnecessary work.
Thus building web applications ground-up, starting from data model, may be a bad idea.&lt;/p&gt;

&lt;p&gt;The problem with ground-up approach (from data model to UI) is that client can&amp;rsquo;t see and play with the product.
Many user scenarios remains hidden since user never interacted with a product yet.
Accordingly, some &lt;em&gt;not-the-cases&lt;/em&gt; will most likely be implemented since developers usually
don&amp;rsquo;t understand user requirements completely due to miscommunication which is hard to avoid.
When client gets first working prototype a lot of work has already done both on front-end and back-end side.
And if the prototype does not meet the client&amp;rsquo;s expectations, this work is to be thrown away.
The indicator of such situation is when significant changes are done to data model after first version was presented to client.&lt;/p&gt;

&lt;p&gt;Agile methodologies can mitigate the problem:
&lt;a href=&#34;https://www.slideshare.net/RichardPDoerer/what-isagile-henrik-kniberg-august-20-2013/21&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;../../assets/2017/03/what-isagile-henrik-kniberg.jpg&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In iterative development with short iterations, each iteration adds some value.
Client-side, server-side and persistence level are changed together in order to add new functionality.
And the Client should be always happy, even having with a fraction of MVP.&lt;/p&gt;

&lt;p&gt;The question is: &lt;em&gt;&amp;laquo;Should Client be happy with a skateboard?&amp;raquo;&lt;/em&gt;
In a real world Client may need to try a &amp;laquo;bicycle&amp;raquo; before he can say that it looks similar to what she expects to have at the end.&lt;/p&gt;

&lt;p&gt;In such conditions of uncertainty the top-down approach i.e. &lt;strong&gt;&lt;em&gt;UI-first Development&lt;/em&gt;&lt;/strong&gt; may be a better solution.
I&amp;nbsp;think it&amp;rsquo;s even more &amp;laquo;agile&amp;raquo; way since Client&amp;rsquo;s feedback is collected earlier, reducing unnecessary work of the team.&lt;/p&gt;

&lt;h2 id=&#34;development-plan&#34;&gt;Development Plan&lt;/h2&gt;

&lt;p&gt;On following diagram you can see how development phases can be scheduled on a timeline
(Vision and Analysis phases were left behind the scene):
&lt;img src=&#34;../../assets/2017/03/app-development-schedule-v1.svg&#34; alt=&#34;Application Development Schedule&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume, we&amp;rsquo;re going to develop a web application consuming REST/Websockets API from back-end server.&lt;/p&gt;

&lt;h3 id=&#34;1-ui-prototype&#34;&gt;1. UI Prototype&lt;/h3&gt;

&lt;p&gt;Actual development starts with web application prototyping.
First UI mockups are created and presented to Client.
This is typically an single page application (SPA) written using some component framework: Angular, React, whatever developers are confident with.
If there is some visual prototype or screen mockups then initial version can be created quickly.&lt;/p&gt;

&lt;h3 id=&#34;2-add-some-static-data&#34;&gt;2. Add Some Static Data&lt;/h3&gt;

&lt;p&gt;When initial application structure is clear, it&amp;rsquo;s the time to add some data.
This should not be a real data as there is no real backend to provide it.
It&amp;rsquo;s enough to create some static JSON files and serve them under &lt;code&gt;/assets&lt;/code&gt; or &lt;code&gt;/data&lt;/code&gt; along with JS application.&lt;/p&gt;

&lt;h3 id=&#34;3-start-defining-api-contract&#34;&gt;3. Start Defining API Contract&lt;/h3&gt;

&lt;p&gt;This static data is a foundation of future API specification (contract). The most popular format for writing API specifications is &lt;a href=&#34;https://swagger.io&#34; target=&#34;_blank&#34;&gt;OpenAPI/Swagger&lt;/a&gt;. It suites well for most common cases. Some aspects, like inheritance, are not clear enough in specification but the format is widely accepted in the industry so it&amp;rsquo;s a default choice.&lt;/p&gt;

&lt;p&gt;Alternative formats for describing REST API are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://apiblueprint.org/&#34; target=&#34;_blank&#34;&gt;API Blueprint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mashape.com&#34; target=&#34;_blank&#34;&gt;Mashape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mashery/iodocs&#34; target=&#34;_blank&#34;&gt;Mashery I/O Docs&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When you have Specification, you can automatically generate and publish API reference documentation.
This will used often by your team internally and you will publish it later if you decide to make your API public.&lt;/p&gt;

&lt;p&gt;There are tools on the market you can use to generate HTML documentation from API Specification.&lt;/p&gt;

&lt;h3 id=&#34;4-a-time-for-testing&#34;&gt;4. A Time for Testing&lt;/h3&gt;

&lt;p&gt;Now you have web application fed with static data. It&amp;rsquo;s time to write some tests.
You may start testing some base functionality you&amp;rsquo;re confident with.
Web Developers may start testing web components using JS-stuff like mocha, jasmine or similar framework.&lt;/p&gt;

&lt;p&gt;It is impossible to cover all the cases without real application server. Also, it is very difficult to test requests sent by UI application. But you can test simple scenarios like: &lt;em&gt;&amp;laquo;WHEN user requests some url THEN expected data is shown on page&amp;raquo;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-even-for-system-integration-testing&#34;&gt;5. â€¦Even for System Integration Testing&lt;/h3&gt;

&lt;p&gt;Webapp functional end-to-end testing with test data can be done by web developers.&lt;/p&gt;

&lt;p&gt;System integration testing is usually done by QA team and employs both web and back-end developers.
It usually covers complex interaction scenarios between front-end and back-end.&lt;/p&gt;

&lt;p&gt;Common tool used for system integration testing is &lt;a href=&#34;http://www.seleniumhq.org&#34; target=&#34;_blank&#34;&gt;Selenium&lt;/a&gt;.
Sometimes it is also necessary to develop some extra tools for direct access to underlaying data and external system emulators (test doubles).
And often the team will end up designing a custom test DSL to simplify writing this kind of tests&lt;/p&gt;

&lt;p&gt;There is a long way to go but even now it&amp;rsquo;s possible to star writing some simple tests&lt;/p&gt;

&lt;p&gt;And it is now possible to start creating System Integration tests.
Even you have no back-end yet, you defined an expected data in static files so there is nothing preventing from using a heavy stuff like Selenium.&lt;/p&gt;

&lt;h3 id=&#34;6-starting-back-end-mock-controllers&#34;&gt;6. Starting Back-End: Mock Controllers&lt;/h3&gt;

&lt;p&gt;We have a contract (API specification) and test data in static files (data should match the contract).
We have also some system integration tests.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s concentrate on deployment and testing. We don&amp;rsquo;t need to implement services and data layer so far.&lt;/p&gt;

&lt;p&gt;Now we need a back-end and full deployment cycle to test both front-end and back-end together.
From a API specification we may generate data transfer objects and interfaces of front controllers.
Then we should implement controllers so they return the same test data.
Mock controllers are enough. They may serve the same static data as for webapp.&lt;/p&gt;

&lt;p&gt;The most important that after completing this step our system integration tests should run against real UI working win real server. And tests should be green.&lt;/p&gt;

&lt;h3 id=&#34;7-continuing-back-end-controllers-and-mock-dao&#34;&gt;7. Continuing Back-End: Controllers and Mock DAO&lt;/h3&gt;

&lt;p&gt;Now it&amp;rsquo;s time to implement services, one by one. Database is still not necessary - we may mock persistence (DAO) layer.
The tests still should be green and we may add more tests now since we have Services now.&lt;/p&gt;

&lt;h3 id=&#34;8-continuing-back-end-real-database-and-dao&#34;&gt;8. Continuing Back-End: Real Database and DAO&lt;/h3&gt;

&lt;p&gt;Now we should design our persistence layer, create DAO add test data so the tests are still green.
After that we&amp;rsquo;ll have all components in our system:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web Application&lt;/li&gt;
&lt;li&gt;REST API Specification&lt;/li&gt;
&lt;li&gt;Backend: Controllers, Services, DAO&lt;/li&gt;
&lt;li&gt;Database&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;rsquo;s continue with short interactions affecting all system layers.&lt;/p&gt;

&lt;h2 id=&#34;final-notes&#34;&gt;Final Notes&lt;/h2&gt;

&lt;p&gt;This not a methodology. It&amp;rsquo;s just the idea of how to minimize unnecessary work in conditions of business uncertainty.
Don&amp;rsquo;t use this instruction blindly.&lt;/p&gt;

&lt;h2 id=&#34;links&#34;&gt;Links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slideshare.net/RichardPDoerer/what-isagile-henrik-kniberg-august-20-2013/21&#34; target=&#34;_blank&#34;&gt;&amp;laquo;What is Agile&amp;raquo; by Henrik Kniberg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/9LfmrkyP81M&#34; target=&#34;_blank&#34;&gt;Writing Software by David Heinemeier Hansson (video, RailsConf 2014)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Authentication: Generating HMAC digest in PHP and Java</title>
      <link>https://konstantinpavlov.net/blog/2015/05/20/api-authentication-generating-hmac-digest-in-php-and-java/</link>
      <pubDate>Wed, 20 May 2015 22:24:47 +0000</pubDate>
      
      <guid>https://konstantinpavlov.net/blog/2015/05/20/api-authentication-generating-hmac-digest-in-php-and-java/</guid>
      <description>&lt;p&gt;User authentication is an important part of the web service API design.
One of the common approach is the Hash-based Message Authentication Code &amp;ndash; &lt;abbr title=&#34;Hash-based Message Authentication Code&#34;&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Hash-based_message_authentication_code&#34; title=&#34;Hash-based message authentication code&#34; target=&#34;_blank&#34;&gt;HMAC&lt;/a&gt;&lt;/abbr&gt;.
Used together with transport level security it provides reliable mechanizm of user authentication and message integrity validation.
&lt;/p&gt;

&lt;p&gt;Imagine, we want to create java web service for our customers.
Data encryption will be guaranteed by using https connection with TLS.
We will implement API user authentication by using public &lt;em&gt;API Key ID&lt;/em&gt; and a &lt;em&gt;API Key Secret&lt;/em&gt;.
User should generate an API Key: unique pair of &lt;em&gt;Key ID&lt;/em&gt; and a &lt;em&gt;Key Secret&lt;/em&gt; for his application.
User should send that &lt;em&gt;Key ID&lt;/em&gt;, message payload and a &lt;em&gt;digest&lt;/em&gt; with every request.
Digest is generated by signing all HTTP headers and message payload with &lt;em&gt;Key Secret&lt;/em&gt;.
(see &lt;a href=&#34;http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheCanonicalizedResourceElement&#34; title=&#34;Signing and Authenticating REST Requests by Amazon&#34; target=&#34;_blank&#34;&gt;Amazon&amp;rsquo;s recommendations&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;In PHP there is a function &lt;a href=&#34;http://php.net/manual/en/function.hash-hmac.php&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;hash_hmac&lt;/code&gt;&lt;/a&gt; for generating keyed hash value using the HMAC method. Here is the example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

$keyId = &#39;d36cb306-9341-466f-a794-d49fbc485d8b&#39;;
$payload = &#39;{&amp;quot;command&amp;quot;: &amp;quot;buy&amp;quot;, &amp;quot;amount&amp;quot;:10, currency&amp;quot;:&amp;quot;EURUSD&amp;quot;}&#39;;
$secret = &#39;se1cr2et3w0r4d&#39;;

echo &#39;SHA-512 HMAC Digest: &#39;, hash_hmac(&#39;sha512&#39;, $keyId . $payload, $secret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SHA-512 HMAC Digest: 577a7927f55bc6ed1eaec08f7298e7c7596b6f951c4c6e8f24324fd9a1f0790adfdecbbd5ab73ad543fec7e6c3c23246a5dd8fae526e0b802ae99faccd06a29c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Call PHP function &lt;a href=&#34;http://php.net/manual/en/function.hash-algos.php&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;hash_algos&lt;/code&gt;&lt;/a&gt; to get a list of supported algorithms.&lt;/p&gt;

&lt;p&gt;How to validate the digest in Java:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String apiKey = ... // X-KEY
byte[] secret = ... //
String rawPayload = ...
String receivedDigest = ... //
...

Mac digest = Mac.getInstance(&amp;quot;HmacSHA512&amp;quot;);
SecretKeySpec secretKey = new SecretKeySpec(secret, HMAC_SHA_512);

digest.init(secretKey);
digest.update(apiKey.getBytes(StandardCharsets.UTF_8));
digest.update(rawPayload.getBytes(StandardCharsets.UTF_8));
final byte[] expectedDigest = digest.doFinal();
digest.reset();

final byte[] receivedDigestBytes = DatatypeConverter.parseHexBinary(receivedDigest);
if (!MessageDigest.isEqual(receivedDigestBytes, expectedDigest)) {
    // invalid digest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheCanonicalizedResourceElement&#34; title=&#34;Signing and Authenticating REST Requests by Amazon&#34; target=&#34;_blank&#34;&gt;Amazon: Signing and Authenticating REST Requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oclc.org/developer/develop/authentication/hmac-signature.en.html&#34; target=&#34;_blank&#34;&gt;OCLC: HMAC Signature&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.coinbase.com/docs/wallet/api-key-authentication&#34; target=&#34;_blank&#34;&gt;Coinbase: API Key Authentication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://restcookbook.com/Basics/loggingin/&#34; target=&#34;_blank&#34;&gt;The RESTful CookBook: HMAC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>